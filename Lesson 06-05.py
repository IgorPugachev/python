# Создаем класс
class Stationery:
# у которого создаем атрибут title
# что мне непонятно: ведь код впоследствии работает нормально (в том числе и у дочерних классов)
# с этим атрибутом, даже я создаю атрибут только одной строкой, без кода:
#    def __init__(self, title):
#        self.title = title

# А во всех ситуациях надо использовать конструктор или нет?

    title = "Канцелярская принадлежность"
# и метод, который выводит сообщение
    def draw(self):
        print("Запуск отрисовки.")

# создаем три дочерних класса. У каждого из них переопределяем метод draw
# можно задать, что они наследуют атрибут title:
#     def __init__(self, title):
#         super().__init__(title)
# Но для этого атрибут надо создавать изначально с использованием конструктора
# Но это происходит и без явного
# указания на это в коде
class Pen(Stationery):

    def draw(self):
        print("Рисуем ручкой.")


class Pencil(Stationery):
    def draw(self):
        print("Рисуем карандашом.")


class Handle(Stationery):
    def draw(self):
        print("Рисуем маркером.")


pen = Pen()
print(pen.draw())
pencil = Pencil()
print(pencil.draw())
handle = Handle()
print(handle.draw())

# Так и не понял, в чем причина - после вывода метода для каждого экземпляра система также
# выводит сообщение None. О чем она говорит, что это?
